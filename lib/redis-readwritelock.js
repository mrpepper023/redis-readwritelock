// Generated by CoffeeScript 1.9.2
(function() {
  var cs, init, isconflictrangelock, lockconfig, locklog, locks, multilock, pwrlock, randomwait, rangelocks, rangepwrlock, rangepwrlock_shrink, rangereaderlock, rangereaderlock_shrink, rangewriterlock, rangewriterlock_shrink, rcli, readerlock, redis, regist_uselocks, resetrangelockname, rwlocks, simplelock, unlock, uselocks, writerlock,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cs = require('control-structures');

  redis = require("redis");

  rcli = redis.createClient();

  lockconfig = {};

  locks = {};

  rwlocks = {};

  rangelocks = {};

  uselocks = ['redislock:keys', ''];

  regist_uselocks = function(lockname) {
    uselocks[1] = lockname;
    return rcli.SADD(uselocks, function() {});
  };

  randomwait = function(waittimeobj, next) {
    if (waittimeobj.time >= lockconfig.waitmax) {
      waittimeobj.time = lockconfig.waitmin;
    } else {
      waittimeobj.time *= Math.random() + Math.random() + Math.random();
    }
    return setTimeout(next, Math.floor(waittimeobj.time - lockconfig.waitmin));
  };

  locklog = function(lockobj, message) {
    var logstr;
    if (lockconfig.log) {
      logstr = '';
      if (/^wait/.test(message) && !lockconfig.logwait) {
        return;
      }
      if (/^shrink/.test(message) && !lockconfig.logshrink) {
        return;
      }
      switch (lockobj.type) {
        case 'simple':
          if (lockconfig.logsimple) {
            logstr = lockobj.obj + '[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'multi':
          if (lockconfig.logsimple) {
            logstr = lockobj.obj + '[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'reader':
          if (lockconfig.logrw) {
            logstr = lockobj.obj + '[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'pwr':
          if (lockconfig.logrw) {
            logstr = lockobj.obj + '[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'writer':
          if (lockconfig.logrw) {
            logstr = lockobj.obj + '[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'rangereader':
          if (lockconfig.logrange) {
            logstr = lockobj.name + '(' + lockobj.min + ',' + lockobj.max + ')[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'rangepwr':
          if (lockconfig.logrange) {
            logstr = lockobj.name + '(' + lockobj.min + ',' + lockobj.max + ')[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'rangewriter':
          if (lockconfig.logrange) {
            logstr = lockobj.name + '(' + lockobj.min + ',' + lockobj.max + ')[' + lockobj.type + ']';
          } else {
            return;
          }
          break;
        case 'rangewriter-upgrade':
          if (lockconfig.logrange) {
            logstr = lockobj.name + '(' + lockobj.min + ',' + lockobj.max + ')[' + lockobj.type + ']';
          } else {
            return;
          }
      }
      logstr += ' ' + message;
      return console.log(logstr);
    }
  };

  resetrangelockname = function(lockobj, next) {
    if (lockobj.name > 99999999) {
      return rcli.ZADD([lockobj.live, lockobj.name, lockobj.name], function(err, reply) {
        return rcli.ZRANGE([lockobj.live, 0, 0, 'WITHSCORES'], function(err, replies) {
          if (replies[1] > 99999999) {
            return rcli.DECRBY([objectname + ':uniquename', 99999999], function(err, reply) {
              return next();
            });
          }
        });
      });
    } else {
      return next();
    }
  };


  /*
     初期化：前回起動時に使ったロックを全部削除する
   */

  module.exports.init = init = function(config, cleanflag, next) {
    var ref, ref1;
    lockconfig = config;
    lockconfig.waitmax = (ref = lockconfig.waitmax) != null ? ref : 200;
    lockconfig.waitmin = (ref1 = lockconfig.waitmin) != null ? ref1 : 4;
    lockconfig['log'] = true;
    lockconfig['logwait'] = false;
    lockconfig['logshrink'] = false;
    lockconfig['logsimple'] = false;
    lockconfig['logrw'] = false;
    lockconfig['logrange'] = false;
    if (lockconfig.log) {
      console.log('init');
    }
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    if (cleanflag) {
      return rcli.SMEMBERS(['redislock:keys'], function(err, replies) {
        replies.push('redislock:keys');
        return rcli.DEL(replies, function(err, reply) {
          return next();
        });
      });
    } else {
      return next();
    }
  };


  /*
     アンロックは共通
   */

  module.exports.unlock = unlock = function(lockobj, next) {
    var args;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    if (((lockobj != null ? lockobj.obj : void 0) != null) && (lockobj.type != null)) {
      switch (lockobj.type) {
        case 'simple':
          return rcli.DEL(lockobj.obj, function(err, reply) {
            locklog(lockobj, 'unlocked');
            return next();
          });
        case 'multi':
          if (lockobj.obj.length > 0) {
            rcli.DEL(lockobj.obj, function(err, reply) {
              locklog(lockobj, 'unlocked');
              return next();
            });
          }
          return next();
        case 'reader':
          return rcli.DECR([lockobj.obj], function(err, reply) {
            locklog(lockobj, 'unlocked');
            return next();
          });
        case 'pwr':
          return rcli.DECRBY([lockobj.obj, 50000], function(err, reply) {
            locklog(lockobj, 'unlocked');
            return next();
          });
        case 'writer':
          return rcli.DECRBY([lockobj.obj, 100000], function(err, reply) {
            locklog(lockobj, 'unlocked');
            if (lockobj.score === 150000) {
              delete lockobj.score;
              lockobj.type = 'pwr';
            }
            return next();
          });
        case 'rangereader':
          locklog(lockobj, 'unlocked');
          args = [lockobj.live, lockobj.name];
          return rcli.ZREM(args, function(err, reply) {
            args[0] = lockobj.robj;
            args[1] = lockobj.name + ':left';
            return rcli.ZREM(args, function(err, reply) {
              args[1] = lockobj.name + ':right';
              return rcli.ZREM(args, function(err, reply) {
                return resetrangelockname(lockobj, next);
              });
            });
          });
        case 'rangepwr':
          locklog(lockobj, 'unlocked');
          return writerlock(lockobj.obj, function(metalockobj) {
            args = [lockobj.live, lockobj.name];
            return rcli.ZREM(args, function(err, reply) {
              args[0] = lockobj.pwrobj;
              args[1] = lockobj.name + ':left';
              return rcli.ZREM(args, function(err, reply) {
                args[1] = lockobj.name + ':right';
                return rcli.ZREM(args, function(err, reply) {
                  return unlock(metalockobj, function() {
                    return resetrangelockname(lockobj, next);
                  });
                });
              });
            });
          });
        case 'rangewriter':
          locklog(lockobj, 'unlocked');
          return writerlock(lockobj.obj, function(metalockobj) {
            args = [lockobj.live, lockobj.name];
            return rcli.ZREM(args, function(err, reply) {
              args[0] = lockobj.wobj;
              args[1] = lockobj.name + ':left';
              return rcli.ZREM(args, function(err, reply) {
                args[1] = lockobj.name + ':right';
                return rcli.ZREM(args, function(err, reply) {
                  return unlock(metalockobj, function() {
                    return resetrangelockname(lockobj, next);
                  });
                });
              });
            });
          });
        case 'rangewriter-upgrade':
          locklog(lockobj, 'unlocked');
          return writerlock(lockobj.obj, function(metalockobj) {
            args = [lockobj.wobj, lockobj.name + ':left'];
            return rcli.ZREM(args, function(err, reply) {
              args[1] = lockobj.name + ':right';
              return rcli.ZREM(args, function(err, reply) {
                return unlock(metalockobj, function() {
                  return resetrangelockname(lockobj, next);
                });
              });
            });
          });
        default:
          console.log('unknown lockobj.type is found! [' + lockobj.type + ']');
          return process.exit(1);
      }
    } else {
      console.log('lockobj is empty!');
      return process.exit(1);
    }
  };


  /*
     単一ロック
   */

  module.exports.simplelock = simplelock = function(objectname, next) {
    var lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {
      type: 'simple',
      obj: objectname + ':lock'
    };
    return cs._while([], function(_break, _next) {
      if (!(indexOf.call(locks, objectname) >= 0)) {
        locks[objectname] = true;
        regist_uselocks(objectname + ':lock');
      }
      return rcli.SETNX([objectname + ':lock', 'ok'], function(err, reply) {
        if (reply === 1) {
          return _break();
        } else {
          locklog(lockobj, 'waiting');
          return randomwait(waittimeobj, _next);
        }
      });
    }, function() {
      locklog(lockobj, 'locked');
      return next(lockobj);
    });
  };


  /*
     複数ロック
   */

  module.exports.multilock = multilock = function(objectarray, next) {
    var i, len, lockargs, lockobj, obj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {};
    lockobj['type'] = 'multi';
    lockobj['obj'] = [];
    lockargs = [];
    for (i = 0, len = objectarray.length; i < len; i++) {
      obj = objectarray[i];
      lockobj.obj.push(obj + ':lock');
      lockargs.push(obj + ':lock');
      lockargs.push('ok');
      if (!(indexOf.call(locks, obj) >= 0)) {
        locks[obj] = true;
        regist_uselocks(obj + ':lock');
      }
    }
    return cs._while([], function(_break, _next) {
      return rcli.MSETNX(lockargs, function(err, reply) {
        if (reply === 1) {
          return _break();
        } else {
          locklog(lockobj, 'waiting');
          return randomwait(waittimeobj, _next);
        }
      });
    }, function() {
      locklog(lockobj, 'locked');
      return next(lockobj);
    });
  };


  /*
     Readerロック
   */

  module.exports.readerlock = readerlock = function(objectname, next) {
    var args, lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {};
    lockobj['type'] = 'reader';
    lockobj['obj'] = objectname + ':rwlock';
    if (!(indexOf.call(rwlocks, objectname) >= 0)) {
      rwlocks[objectname] = true;
      regist_uselocks(objectname + ':rwlock');
    }
    args = [lockobj.obj];
    return rcli.INCR(args, function(err, reply) {
      if (reply >= 99999) {
        return rcli.DECR(args, function(err, reply) {
          return cs._while([], function(_break, _next) {
            return rcli.GET(args, function(err, reply) {
              if (reply < 99999) {
                return rcli.INCR(args, function(err, reply) {
                  if (reply < 99999) {
                    return _break();
                  } else {
                    return rcli.DECR(args, function(err, reply) {
                      locklog(lockobj, 'waiting1');
                      return randomwait(waittimeobj, _next);
                    });
                  }
                });
              } else {
                locklog(lockobj, 'waiting2');
                return randomwait(waittimeobj, _next);
              }
            });
          }, function() {
            locklog(lockobj, 'locked');
            return next(lockobj);
          });
        });
      } else {
        locklog(lockobj, 'locked');
        return next(lockobj);
      }
    });
  };


  /*
     PreWrite-Readロック
   */

  module.exports.pwrlock = pwrlock = function(objectname, next) {
    var args, lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    lockobj = {};
    lockobj['type'] = 'pwr';
    lockobj['obj'] = objectname + ':rwlock';
    if (!(indexOf.call(rwlocks, objectname) >= 0)) {
      rwlocks[objectname] = true;
      regist_uselocks(objectname + ':rwlock');
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    args = [lockobj.obj, 50000];
    return rcli.INCRBY(args, function(err, reply) {
      if (reply >= 99999) {
        return rcli.DECRBY(args, function(err, reply) {
          return cs._while([], function(_break, _next) {
            return rcli.GET([lockobj.obj], function(err, reply) {
              if (reply < 49999) {
                return rcli.INCRBY(args, function(err, reply) {
                  if (reply < 99999) {
                    return _break();
                  } else {
                    return rcli.DECRBY(args, function(err, reply) {
                      locklog(lockobj, 'waiting1');
                      return randomwait(waittimeobj, _next);
                    });
                  }
                });
              } else {
                locklog(lockobj, 'waiting2');
                return randomwait(waittimeobj, _next);
              }
            });
          }, function() {
            locklog(lockobj, 'locked');
            return next(lockobj);
          });
        });
      } else {
        locklog(lockobj, 'locked');
        return next(lockobj);
      }
    });
  };


  /*
     Writerロック
   */

  module.exports.writerlock = writerlock = function(objectname_or_lockobj, next) {
    var args, basescore, getargs, lockobj, replyvalue, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    basescore = 0;
    if (objectname_or_lockobj != null) {
      if ((objectname_or_lockobj.type != null) && objectname_or_lockobj.type === 'pwr') {
        lockobj = objectname_or_lockobj;
        lockobj.type = 'writer';
        lockobj['score'] = 150000;
        basescore = 50000;
      } else {
        lockobj = {};
        lockobj['type'] = 'writer';
        lockobj['obj'] = objectname_or_lockobj + ':rwlock';
        lockobj['score'] = 100000;
        if (!(indexOf.call(rwlocks, objectname_or_lockobj) >= 0)) {
          rwlocks[objectname_or_lockobj] = true;
          regist_uselocks(objectname_or_lockobj + ':rwlock');
        }
      }
    } else {
      console.log('objectname_or_lockobj is null.');
      process.exit(1);
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    replyvalue = 0;
    getargs = [lockobj.obj];
    args = [lockobj.obj, 100000];
    return rcli.INCRBY(args, function(err, reply) {
      replyvalue = reply;
      return cs._([], function(localnext) {
        if (replyvalue >= 150000 + basescore) {
          return rcli.DECRBY(args, function(err, reply) {
            return cs._while([], function(_break, _next) {
              return rcli.INCRBY(args, function(err, reply) {
                replyvalue = reply;
                if (replyvalue >= 150000 + basescore) {
                  return rcli.DECRBY(args, function(err, reply) {
                    locklog(lockobj, 'waiting1');
                    return randomwait(waittimeobj, _next);
                  });
                } else {
                  return _break();
                }
              });
            }, function() {
              return localnext();
            });
          });
        } else {
          return localnext();
        }
      }, function() {
        waittimeobj.time = lockconfig.waitmin;
        if (replyvalue >= 100001 + basescore) {
          return cs._while([], function(_break, _next) {
            return rcli.GET(getargs, function(err, reply) {
              if (reply <= 100000 + basescore) {
                return _break();
              } else {
                locklog(lockobj, 'waiting2');
                return randomwait(waittimeobj, _next);
              }
            });
          }, function() {
            locklog(lockobj, 'locked');
            return next(lockobj);
          });
        } else if (replyvalue === 100000 + basescore) {
          locklog(lockobj, 'locked');
          return next(lockobj);
        } else {
          console.log('unknown error (reply = ' + reply);
          return process.exit(1);
        }
      });
    });
  };

  isconflictrangelock = function(targetobj, rangemin, rangemax, threshold, next) {
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    return rcli.ZCOUNT([targetobj, rangemin, rangemax], function(err, reply) {
      if (reply <= threshold * 2) {
        return rcli.ZRANGEBYSCORE([targetobj, '-inf', rangemin], function(err, replies) {
          var i, len, tablemem;
          if (replies.length === 0) {
            return next(false);
          } else {
            tablemem = 0;
            for (i = 0, len = replies.length; i < len; i++) {
              reply = replies[i];
              if (/\:left$/.test(reply)) {
                tablemem += 1;
              } else if (/\:right$/.test(reply)) {
                tablemem -= 1;
              } else {
                console.log(reply + ' is an illegal range mark.');
                process.exit(1);
              }
            }
            return next(tablemem > threshold);
          }
        });
      } else {
        return next(true);
      }
    });
  };


  /*
     RangeReaderロック
   */

  module.exports.rangereaderlock = rangereaderlock = function(objectname, rangemin, rangemax, next) {
    var lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {};
    lockobj['type'] = 'rangereader';
    lockobj['name'] = '';
    lockobj['obj'] = objectname + ':meta';
    lockobj['min'] = rangemin;
    lockobj['max'] = rangemax;
    lockobj['robj'] = objectname + ':readerlockzset';
    lockobj['pwrobj'] = objectname + ':pwrlockzset';
    lockobj['wobj'] = objectname + ':writerlockzset';
    lockobj['live'] = objectname + ':alivelockzset';
    if (!(indexOf.call(rangelocks, objectname) >= 0)) {
      rangelocks[objectname] = true;
      regist_uselocks(objectname + ':readerlockzset');
      regist_uselocks(objectname + ':pwrlockzset');
      regist_uselocks(objectname + ':writerlockzset');
      regist_uselocks(objectname + ':alivelockzset');
      regist_uselocks(objectname + ':uniquename');
    }
    return cs._([], function(localnext) {
      return rcli.INCR([objectname + ':uniquename'], function(err, reply) {
        lockobj.name = reply;
        return localnext();
      });
    }, function() {
      return cs._while([], function(_break, _next) {
        return readerlock(lockobj.obj, function(metalockobj) {
          return isconflictrangelock(lockobj.wobj, rangemin, rangemax, 0, function(isconflict) {
            var args;
            if (!isconflict) {
              args = [lockobj.robj, rangemin, lockobj.name + ':left'];
              return rcli.ZADD(args, function(err, reply) {
                args[1] = rangemax;
                args[2] = lockobj.name + ':right';
                return rcli.ZADD(args, function(err, reply) {
                  return unlock(metalockobj, function() {
                    return _break();
                  });
                });
              });
            } else {
              return unlock(metalockobj, function() {
                locklog(lockobj, 'waiting');
                return randomwait(waittimeobj, _next);
              });
            }
          });
        });
      }, function() {
        locklog(lockobj, 'locked');
        return next(lockobj);
      });
    });
  };


  /*
     RangeReaderロックの対象を縮小する
   */

  module.exports.rangereaderlock_shrink = rangereaderlock_shrink = function(lockobj, rangemin, rangemax, next) {
    var args;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    if (lockobj.type === 'rangereader' && lockobj.min <= rangemin && rangemin <= rangemax && rangemax <= lockobj.max) {
      args = [lockobj.robj, rangemin, lockobj.name + ':left'];
      return rcli.ZADD(args, function(err, reply) {
        args[1] = rangemax;
        args[2] = lockobj.name + ':right';
        return rcli.ZADD(args, function(err, reply) {
          lockobj.min = rangemin;
          lockobj.max = rangemax;
          locklog(lockobj, 'shrinked');
          return next(lockobj);
        });
      });
    } else {
      console.log('err');
      return process.exit(1);
    }
  };


  /*
     RangePWRロック
   */

  module.exports.rangepwrlock = rangepwrlock = function(objectname, rangemin, rangemax, next) {
    var lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {};
    lockobj['type'] = 'rangepwr';
    lockobj['name'] = '';
    lockobj['obj'] = objectname + ':meta';
    lockobj['min'] = rangemin;
    lockobj['max'] = rangemax;
    lockobj['robj'] = objectname + ':readerlockzset';
    lockobj['pwrobj'] = objectname + ':pwrlockzset';
    lockobj['wobj'] = objectname + ':writerlockzset';
    lockobj['live'] = objectname + ':alivelockzset';
    if (!(indexOf.call(rangelocks, objectname) >= 0)) {
      rangelocks[objectname] = true;
      regist_uselocks(objectname + ':readerlockzset');
      regist_uselocks(objectname + ':pwrlockzset');
      regist_uselocks(objectname + ':writerlockzset');
      regist_uselocks(objectname + ':alivelockzset');
      regist_uselocks(objectname + ':uniquename');
    }
    return cs._([], function(localnext) {
      return rcli.INCR([objectname + ':uniquename'], function(err, reply) {
        lockobj.name = reply;
        return localnext();
      });
    }, function() {
      return cs._while([], function(_break, _next) {
        return pwrlock(lockobj.obj, function(metalockobj) {
          return isconflictrangelock(lockobj.pwrobj, lockobj.min, lockobj.max, 0, function(isconflict) {
            if (!isconflict) {
              return isconflictrangelock(lockobj.wobj, lockobj.min, lockobj.max, 0, function(isconflict) {
                if (!isconflict) {
                  return writerlock(metalockobj, function(metalockobj) {
                    var args;
                    args = [lockobj.pwrobj, lockobj.min, lockobj.name + ':left'];
                    return rcli.ZADD(args, function(err, reply) {
                      args[1] = lockobj.max;
                      args[2] = lockobj.name + ':right';
                      return rcli.ZADD(args, function(err, reply) {
                        return unlock(metalockobj, function() {
                          return unlock(metalockobj, function() {
                            return _break();
                          });
                        });
                      });
                    });
                  });
                } else {
                  return unlock(metalockobj, function() {
                    locklog(lockobj, 'waiting');
                    return randomwait(waittimeobj, _next);
                  });
                }
              });
            } else {
              return unlock(metalockobj, function() {
                return randomwait(waittimeobj, _next);
              });
            }
          });
        });
      }, function() {
        locklog(lockobj, 'locked');
        return next(lockobj);
      });
    });
  };


  /*
     RangePWRロックの対象を縮小する
   */

  module.exports.rangepwrlock_shrink = rangepwrlock_shrink = function(lockobj, rangemin, rangemax, next) {
    var args;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    if (lockobj.type === 'rangepwr' && lockobj.min <= rangemin && rangemin <= rangemax && rangemax <= lockobj.max) {
      args = [lockobj.pwrobj, rangemin, lockobj.name + ':left'];
      return rcli.ZADD(args, function(err, reply) {
        args[1] = rangemax;
        args[2] = lockobj.name + ':right';
        return rcli.ZADD(args, function(err, reply) {
          lockobj.min = rangemin;
          lockobj.max = rangemax;
          locklog(lockobj, 'shrinked');
          return next(lockobj);
        });
      });
    } else {
      console.log('err');
      return process.exit(1);
    }
  };


  /*
     RangeWriterロック
   */

  module.exports.rangewriterlock = rangewriterlock = function(objectname_or_lockobj, rangemin, rangemax, next) {
    var basename, lockobj, waittimeobj;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    waittimeobj = {
      time: lockconfig.waitmin
    };
    lockobj = {};
    basename = '';
    if (objectname_or_lockobj == null) {
      console.log('error');
      return process.exit(1);
    } else {
      return cs._([], function(localnext1) {
        var pwrmax, pwrmin;
        if ((objectname_or_lockobj.type != null) && objectname_or_lockobj.type === 'rangepwr') {
          lockobj['obj'] = objectname_or_lockobj.obj;
          basename = objectname_or_lockobj.obj.replace(/\:meta$/, '');
          lockobj['type'] = 'rangewriter-upgrade';
          pwrmin = objectname_or_lockobj.min;
          pwrmax = objectname_or_lockobj.max;
          if (pwrmin <= rangemin && rangemin <= rangemax && rangemax <= pwrmax) {
            lockobj['min'] = rangemin;
            lockobj['max'] = rangemax;
            return localnext1(basename);
          } else {
            console.log('error');
            return process.exit(1);
          }
        } else {
          lockobj['obj'] = objectname_or_lockobj + ':meta';
          basename = objectname_or_lockobj;
          lockobj['type'] = 'rangewriter';
          lockobj['min'] = rangemin;
          lockobj['max'] = rangemax;
          return localnext1(basename);
        }
      }, function(localnext2, basename) {
        lockobj['robj'] = basename + ':readerlockzset';
        lockobj['pwrobj'] = basename + ':pwrlockzset';
        lockobj['wobj'] = basename + ':writerlockzset';
        lockobj['live'] = basename + ':alivelockzset';
        if (!(indexOf.call(rangelocks, basename) >= 0)) {
          rangelocks[basename] = true;
          regist_uselocks(basename + ':readerlockzset');
          regist_uselocks(basename + ':pwrlockzset');
          regist_uselocks(basename + ':writerlockzset');
          regist_uselocks(basename + ':alivelockzset');
          regist_uselocks(basename + ':uniquename');
        }
        return rcli.INCR([basename + ':uniquename'], function(err, reply) {
          lockobj.name = reply;
          if ((objectname_or_lockobj.type != null) && objectname_or_lockobj.type === 'rangepwr') {
            return pwrlock(lockobj.obj, function(metalockobj) {
              return localnext2(metalockobj);
            });
          } else {
            return cs._while([], function(_break, _next) {
              return pwrlock(lockobj.obj, function(metalockobj) {
                return isconflictrangelock(lockobj.pwrobj, lockobj.min, lockobj.max, 0, function(isconflict) {
                  if (!isconflict) {
                    return isconflictrangelock(lockobj.wobj, lockobj.min, lockobj.max, 0, function(isconflict) {
                      if (!isconflict) {
                        return _break(metalockobj);
                      } else {
                        return unlock(metalockobj, function() {
                          locklog(lockobj, 'waiting1');
                          return randomwait(waittimeobj, _next);
                        });
                      }
                    });
                  } else {
                    return unlock(metalockobj, function() {
                      locklog(lockobj, 'waiting2');
                      return randomwait(waittimeobj, _next);
                    });
                  }
                });
              });
            }, function(metalockobj) {
              return localnext2(metalockobj);
            });
          }
        });
      }, function(_dummynext, metalockobj) {
        return writerlock(metalockobj, function(metalockobj) {
          var args;
          args = [lockobj.wobj, lockobj.min, lockobj.name + ':left'];
          return rcli.ZADD(args, function(err, reply) {
            args[1] = lockobj.max;
            args[2] = lockobj.name + ':right';
            return rcli.ZADD(args, function(err, reply) {
              return unlock(metalockobj, function() {
                return unlock(metalockobj, function() {
                  waittimeobj.time = lockconfig.waitmin;
                  return cs._while([], function(_break, _next) {
                    return isconflictrangelock(lockobj.robj, lockobj.min, lockobj.max, 0, function(isconflict) {
                      if (!isconflict) {
                        return _break();
                      } else {
                        return randomwait(waittimeobj, _next);
                      }
                    });
                  }, function() {
                    locklog(lockobj, 'locked');
                    return next(lockobj);
                  });
                });
              });
            });
          });
        });
      });
    }
  };


  /*
     RangeWriterロックの対象を縮小する
   */

  module.exports.rangewriterlock_shrink = rangewriterlock_shrink = function(lockobj, rangemin, rangemax, next) {
    var args;
    if (next == null) {
      if (lockconfig.log) {
        console.log('no next');
      }
      next = function() {};
    }
    if (lockobj.type === 'rangewriter' && lockobj.min <= rangemin && rangemin <= rangemax && rangemax <= lockobj.max) {
      args = [lockobj.wobj, rangemin, lockobj.name + ':left'];
      return rcli.ZADD(args, function(err, reply) {
        args[1] = rangemax;
        args[2] = lockobj.name + ':right';
        return rcli.ZADD(args, function(err, reply) {
          lockobj.min = rangemin;
          lockobj.max = rangemax;
          locklog(lockobj, 'shrinked');
          return next(lockobj);
        });
      });
    } else {
      console.log('err');
      return process.exit(1);
    }
  };

}).call(this);
